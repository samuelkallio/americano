<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>K√§ynniss√§ oleva kierros ‚Äî Americano</title>
  <link rel="stylesheet" href="style.css" />
  <script type="module" src="common.js"></script>
  <script>
    // current active round (object from store.rounds)
    let currentRound = null;
    // track previous players length to detect fresh name list
    let prevPlayersCount = 0;

    // Helper: find "active" round from rounds array
    function findActiveRound(rounds) {
      if(!rounds || !rounds.length) return null;
      // prefer newest (index 0 from Firestore ordering) that has all scores empty/zero
      for(const r of rounds) {
        if(!r.courts || r.courts.length === 0) continue;
        const allEmpty = r.courts.every(c =>
          (c.scoreHome == null || c.scoreHome === 0) &&
          (c.scoreAway == null || c.scoreAway === 0)
        );
        if(allEmpty) return r;
      }
      // fallback: return newest
      return rounds[0];
    }

    // Render active/current round to table
    function renderCurrentRound() {
      const rounds = window.store?.rounds || [];
      const players = window.store?.players || [];
      const settings = window.store?.settings || { winPoints: 11 };

      // if no players, show message
      if(!players || players.length === 0) {
        document.getElementById('byesList').innerHTML = '';
        document.getElementById('roundTable').innerHTML = '<div class="small">Lis√§√§ pelaajia aloittaaksesi kierroksen.</div>';
        currentRound = null;
        return;
      }

      currentRound = findActiveRound(rounds);
      // If no round and we have players, create one automatically
      if(!currentRound) {
        // show spinner/message while creating
        document.getElementById('byesList').innerHTML = '';
        document.getElementById('roundTable').innerHTML = '<div class="small">Luodaan uutta kierrosta‚Ä¶</div>';
        // attempt to create a new round
        if(window.autoCreateRound) {
          window.autoCreateRound()
            .then(() => {
              // small delay to let live-sync update store
              setTimeout(renderCurrentRound, 600);
            })
            .catch(e => {
              console.error('autoCreateRound failed', e);
              document.getElementById('roundTable').innerHTML = '<div class="small">Uuden kierroksen luonti ep√§onnistui.</div>';
            });
        }
        return;
      }

      // Build table: sort courts by courtNumber desc (largest first)
      const tbl = document.getElementById('roundTable');
      const byesEl = document.getElementById('byesList');
      let html = '<tr><th>Kentt√§</th><th>Koti</th><th>Koti pisteet</th><th>Vieras</th><th>Vieras pisteet</th></tr>';
      const sorted = (currentRound.courts || []).slice().sort((a,b) => b.courtNumber - a.courtNumber);
      for(const c of sorted) {
        const homeNames = (c.home||[]).map(id => getNameById(id)).join(' & ');
        const awayNames = (c.away||[]).map(id => getNameById(id)).join(' & ');
        const maxVal = settings.winPoints || 11;
        const svalH = (c.scoreHome != null) ? c.scoreHome : 0;
        const svalA = (c.scoreAway != null) ? c.scoreAway : 0;
        html += `<tr>
          <td><strong>K${c.courtNumber}</strong></td>
          <td class="player-cell">${escapeHtml(homeNames)}</td>
          <td><input class="score-input" type="number" id="sH${c.courtNumber}" min="0" max="${maxVal}" value="${svalH}" /></td>
          <td class="player-cell">${escapeHtml(awayNames)}</td>
          <td><input class="score-input" type="number" id="sA${c.courtNumber}" min="0" max="${maxVal}" value="${svalA}" /></td>
        </tr>`;
      }
      tbl.innerHTML = html;

      const byes = (currentRound.byes || []).map(id => getNameById(id));
      byesEl.innerHTML = `<strong>Tauolla:</strong> ${byes.length ? escapeHtml(byes.join(', ')) : 'Ei ket√§√§n'}`;
    }

    // small helper to escape text inserted into HTML
    function escapeHtml(s){
      if(!s) return '';
      return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
    }

    // get player name for id using store
    function getNameById(id) {
      const p = (window.store?.players || []).find(x => x.id === id);
      return p ? p.name : '?';
    }

    // score validation: one score exactly wp and greater than other
    function validateScore(sH, sA, wp) {
      if(Number.isNaN(sH) || Number.isNaN(sA)) return false;
      if(sH < 0 || sA < 0) return false;
      if(sH > wp || sA > wp) return false;
      if((sH === wp && sH > sA) || (sA === wp && sA > sH)) return true;
      return false;
    }

    // save results: validates and writes currentRound to Firestore
    async function saveResults() {
      if(!currentRound) {
        // if there are players but no round, create one then show
        if(window.autoCreateRound) {
          try {
            await window.autoCreateRound();
            setTimeout(renderCurrentRound, 600);
          } catch(e) {
            console.error(e);
            showBanner('Uuden kierroksen luonti ep√§onnistui','error');
          }
        } else {
          showBanner('Ei kierrosta tallennettavaksi','error');
        }
        return;
      }

      const wp = window.store?.settings?.winPoints || 11;
      for(const c of currentRound.courts || []) {
        const sH = Number(document.getElementById(`sH${c.courtNumber}`).value || 0);
        const sA = Number(document.getElementById(`sA${c.courtNumber}`).value || 0);
        if(!validateScore(sH, sA, wp)) {
          showBanner(`Virhe kentt√§ ${c.courtNumber}: tarkista tulokset`, 'error');
          return;
        }
      }

      // Apply scores to the object
      for(const c of currentRound.courts || []) {
        c.scoreHome = Number(document.getElementById(`sH${c.courtNumber}`).value || 0);
        c.scoreAway = Number(document.getElementById(`sA${c.courtNumber}`).value || 0);
      }

      try {
        await window.saveRoundToDB(currentRound);
        await window.recomputeAndSavePlayers();
        showBanner('‚úÖ Tulokset tallennettu', 'success');
        // after saving, reset currentRound so next render will create/select a new one
        currentRound = null;
        // small delay to let live sync update
        setTimeout(renderCurrentRound, 700);
      } catch(e) {
        console.error(e);
        showBanner('Tallennus ep√§onnistui','error');
      }
    }

    // Manual create button handler
    async function createNewRoundManually() {
      const players = window.store?.players || [];
      if(!players || players.length === 0) {
        showBanner('Lis√§√§ pelaajia ensin','error');
        return;
      }
      if(!window.autoCreateRound) {
        showBanner('autoCreateRound ei k√§ytett√§viss√§','error');
        return;
      }
      try {
        await window.autoCreateRound();
        showBanner('Uusi kierros luotu','success');
        setTimeout(renderCurrentRound, 600);
      } catch(e) {
        console.error(e);
        showBanner('Kierroksen luonti ep√§onnistui','error');
      }
    }

    // Clear rounds button (optional helper)
    async function clearAllRounds() {
      if(!confirm('Poistetaanko kaikki kierrokset pilvest√§?')) return;
      const rounds = window.store?.rounds || [];
      try {
        for(const r of rounds) {
          if(r.id) await window.deleteRoundFromDB(r.id);
        }
        showBanner('Kierrokset poistettu','success');
      } catch(e) {
        console.error(e);
        showBanner('Kierrosten poisto ep√§onnistui','error');
      }
    }

    // Called by common.js on updates (live sync). We override these to update UI.
    window.updatePlayersUI = function(players) {
      // detect fresh name-list creation: from 0 to >0 -> initialize new round
      const newCount = (players || []).length;
      if(prevPlayersCount === 0 && newCount > 0) {
        // create initial round
        if(window.autoCreateRound) {
          window.autoCreateRound().then(()=> {
            setTimeout(renderCurrentRound, 600);
          }).catch(e => console.error('autoCreateRound failed', e));
        }
      }
      prevPlayersCount = newCount;
      renderCurrentRound();
    };

    window.updateRoundsUI = function(rounds) {
      // simply re-render current round when rounds update
      renderCurrentRound();
    };

    // initial startup
    document.addEventListener('DOMContentLoaded', () => {
      if(window.startLiveSync) window.startLiveSync();
      // initial render after a short delay to allow loadLocal to populate if used
      setTimeout(() => {
        prevPlayersCount = (window.store?.players || []).length;
        renderCurrentRound();
      }, 300);
    });
  </script>

  <style>
    /* small page-specific styles, uses style.css for base */
    .player-cell { padding-right: 8px; }
    .score-input { width: 72px; padding:4px; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px; }
  </style>
</head>
<body>
  <div id="banner" class="banner"></div>

  <div class="container card">
    <h1>K√§ynniss√§ oleva kierros</h1>

    <div class="controls">
      <button onclick="createNewRoundManually()">‚ûï Luo uusi kierros</button>
      <button onclick="saveResults()">üíæ Tallenna tulokset</button>
      <button onclick="clearAllRounds()">üóëÔ∏è Poista kaikki kierrokset</button>
    </div>

    <div id="byesList" class="small" style="margin-bottom:8px"></div>
    <table id="roundTable"></table>
  </div>

  <footer>
    <button onclick="location.href='index.html'">‚öôÔ∏è</button>
    <button onclick="location.href='players.html'">üë•</button>
    <button onclick="location.href='rounds.html'" class="active">üéæ</button>
    <button onclick="location.href='results.html'">üìú</button>
  </footer>
</body>
</html>
